<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="ja">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--ブラウザのアイコンの設定
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/android-chrome-256x256.png">
    -->
    <title>干渉色カメラ</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">

<script>
  /* ピッチインピッチアウトによる拡大縮小を禁止 */
  document.documentElement.addEventListener('touchstart', function (e) {
  if (e.touches.length >= 2) {e.preventDefault();}
  }, {passive: false});
 </script>

	<style>

	html,body{
		touch-action: pan-Y;
	}

  @media screen and (max-width: 768px) {
	/* [iframe]を囲む要素 */
	.iframe-window
	{
		width: 95% ;
		max-width: 480px ;			/* 最大の横幅 */
		height: 0 ;					/* 高さは0にする */
		padding-bottom: 130% ;	/* 横幅に対する縦幅の比率 */
		position: relative ;
		top: 0 ;
		left: 0 ;
	}
	/* [ifram] */
	.iframe-window iframe
	{
		width: 100% ;		/* 親要素の余白いっぱい */
		height: 100% ;		/* 親要素の余白いっぱい */
		margin: 0 ;			/* 余白 */
		padding: 0 ;		/* スペース */
		position: absolute ;
		top: 0 ;
		left: 0 ;
	}
  }

	</style>
</head>
<body>
    <body bgcolor="#FCE3CD" text="#663236" > <!--HTML5非推奨記載なので別途CSSに移行予定-->        
    <!-- link="リンク文字色 " alink="選択中リンク文字色" vlink="訪問済みリンク文字色"> -->
    <div>
        <h2>干渉色カメラ(テスト)</h2>
        <div>
            <canvas id="canvas"></canvas>
        </div>
    </div>  
    <script>
        async function main() {
            // 表示用のCanvas
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            // 画像処理用のオフスクリーンCanvas
            const offscreen = document.createElement("canvas");
            const offscreenCtx = offscreen.getContext("2d");
            // カメラから映像を取得するためのvideo要素
            const video = document.createElement("video");

            const stream = await navigator.mediaDevices.getUserMedia({
                video: true
            });

            video.srcObject = stream;
            // streamの読み込み完了
            video.onloadedmetadata = () => {
                video.play();

                // Canvasのサイズを映像に合わせる
                canvas.width = offscreen.width = video.videoWidth;
                canvas.height = offscreen.height = video.videoHeight;

                tick();
            };

            // 1フレームごとに呼び出される処理
            function tick() {
                // カメラの映像をCanvasに描画する
                offscreenCtx.drawImage(video, 0, 0);

                // イメージデータを取得する（[r,g,b,a,r,g,b,a,...]のように1次元配列で取得できる）
                const imageData = offscreenCtx.getImageData(0, 0, offscreen.width, offscreen.height);
                // imageData.dataはreadonlyなのでfilterメソッドで直接書き換える
                filter(imageData.data);

                // オフスクリーンCanvasを更新する
                offscreenCtx.putImageData(imageData, 0, 0);

                // 表示用Canvasに描画する
                ctx.drawImage(offscreen, 0, 0);

                // 次フレームを処理する
                window.requestAnimationFrame(tick);
            }

            function filter(imgr) {
                // 画像処理を行う
                for (let j = 0; j < imgr.length; j += 4) {
                    //グレースケール変換
                    let Y = 0.299*imgr[j] + 0.587*imgr[j+1] + 0.114*imgr[j+2];
                    //imgr[j]   = Y ;
                    //imgr[j+1] = Y ;
                    //imgr[j+2] = Y ;

                    //グレースケールを干渉色に変換

                    //////干渉色パラメータ
                    t_iC = [0.64 , 0.35 , 0.355]     //振幅　amplitude
                    c_iC = [ 0.5 , 0.5 , 0.5]        //中心値
                    u_iC = [ 0.5 , 0.52 , 0.5]       //位相率
                    k_iC = [ 2.98 , 3.71 , 4.35]     //波数
                    s_iC = [ 0.105 , 0. , 0.]        //波長増加率
                    alpha_iC = [ 0.2 , 0.53 , 0.5]   //包絡振幅
                    delta_iC = [ 0.5 , 0.1 , 0.042]  //包絡位相率
                    beta_iC  = [ 0.7 , 0.45 , 0.35]  //包絡波数

                    cycle = 1.                       //色繰返し回数
                    fullscale = 255.                 //画像輝度の最大値(最大は何メートルか)
                    Num_iC = fullscale / cycle       //色１周期で輝度幾つか(色１周期で何メートルか）
                    scale  = 1000. / fullscale       //画像輝度値の幅を1000に規格化する係数
                    r_iC = 0.15                      //不使用階調率(15%)
                    //////
                    //////変数定義
                    n_iC = Y % Num_iC               //色一周期の何番目か
                    imcl=[]                          //変換後の配列は干渉色計算用に浮動小数点とする
                    //////

                    for (let i = 0; i < 3; i +=1 ){
                        imcl[i] = c_iC[i] + t_iC[i] * ( 1 + alpha_iC[i] * Math.cos ( 2 * Math.PI * beta_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) - 2 * Math.PI * delta_iC[i] ) ) * Math.cos ( 2 * Math.PI * ( 1 + s_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) ) * k_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) - 2 * Math.PI * u_iC[i] );
                        if ( imcl[i] > 0.0031308 ){
                            imcl[i] = 1.055 * ( imcl[i] ** (1/2.4) ) - 0.055
                        }else{
                            imcl[i] = 12.92 * imcl[i]
                        }
                        imgr[j+i] = Math.round(255. * Math.max( 0. , Math.min(1., imcl[i]) ) )
                    }
                }
            }
        }
        main();
    </script> 
</body>
</html>
