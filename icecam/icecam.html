<html lang="ja">
<head>
    <title>干渉色カメラ(テスト)　#世界を干渉色に</title>
</head>
<body>
    <body bgcolor="#FCE3CD" text="#663236" > <!--HTML5非推奨記載なので別途CSSに移行予定-->        
    <!-- link="リンク文字色 " alink="選択中リンク文字色" vlink="訪問済みリンク文字色"> -->
    <div>
        <h2>干渉色カメラ(テスト)　#世界を干渉色に</h2>
        画面の下の「撮影-保存」で撮影・保存できます。画像が動かない場合「リフレッシュ」で画像を更新<br>
        表示や保存できないときは右上の「・・・」の「ブラウザで開く」を試すか、下の「リフレッシュ」か「カメラ切替」を押してください<br>
        <div>
            <canvas id="canvas"></canvas><br>
        </div>
        <h2>
            | <a href='https://ymd5022002.github.io/map-art-jp/icecam/icecam'>リフレッシュ</a> |
            <a href='https://ymd5022002.github.io/map-art-jp/icecam/icecam2'>カメラ切替</a> |
            <a href='#' download='icecam.png' id="save">撮影-保存</a> | <br>
        </h2>
    </div> 
    <script>
        async function main() {
            // 表示用のCanvas
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            // 画像処理用のオフスクリーンCanvas
            const offscreen = document.createElement("canvas");
            const offscreenCtx = offscreen.getContext("2d");
            // カメラから映像を取得するためのvideo要素
            const video = document.createElement("video");

            const stream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: {
                    width: 1024,
                    height: 768,
                    facingMode: "user"   // フロントカメラを利用する
                    // facingMode: { exact: "environment" }  // リアカメラを利用する場合
                }
            });

            video.srcObject = stream;
            // streamの読み込み完了
            video.onloadedmetadata = () => {
                video.play();

                // Canvasのサイズを映像に合わせる
                canvas.width = offscreen.width = video.videoWidth;
                canvas.height = offscreen.height = video.videoHeight;

                tick();
            };

            //グレースケールを干渉色に変換するルックアップテーブルを作成する処理            
            function makeLUTable(){
                
                let LUTable = [];
                //////干渉色パラメータ
                t_iC = [0.64 , 0.35 , 0.355];    //振幅　amplitude
                c_iC = [ 0.5 , 0.5 , 0.5];       //中心値
                u_iC = [ 0.5 , 0.52 , 0.5];      //位相率
                k_iC = [ 2.98 , 3.71 , 4.35];    //波数
                s_iC = [ 0.105 , 0. , 0.];       //波長増加率
                alpha_iC = [ 0.2 , 0.53 , 0.5];  //包絡振幅
                delta_iC = [ 0.5 , 0.1 , 0.042]; //包絡位相率
                beta_iC  = [ 0.7 , 0.45 , 0.35]; //包絡波数

                cycle = 1.                       //色繰返し回数
                fullscale = 255.;                //画像輝度の最大値(最大は何メートルか)
                Num_iC = fullscale / cycle;      //色１周期で輝度幾つか(色１周期で何メートルか）
                scale  = 1000. / fullscale;      //画像輝度値の幅を1000に規格化する係数
                r_iC = 0.15;                     //不使用階調率(15%)

                for (let Y = 0; Y < 256; Y +=1) {
                    n_iC = Y % Num_iC;           //色一周期の何番目か
                    for (let i = 0; i < 3; i +=1 ){
                        LUTable[Y*3 + i] = c_iC[i] + t_iC[i] * ( 1 + alpha_iC[i] * Math.cos ( 2 * Math.PI * beta_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) - 2 * Math.PI * delta_iC[i] ) ) * Math.cos ( 2 * Math.PI * ( 1 + s_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) ) * k_iC[i] * ( n_iC/Num_iC + r_iC ) / ( 1 + r_iC ) - 2 * Math.PI * u_iC[i] );
                        if ( LUTable[Y*3 + i] > 0.0031308 ){
                            LUTable[Y*3 + i] = 1.055 * ( LUTable[Y*3 + i] ** (1/2.4) ) - 0.055;
                        }else{
                            LUTable[Y*3 + i] = 12.92 * LUTable[Y*3 + i];
                        }
                        LUTable[Y*3 + i] = Math.round(255. * Math.max( 0. , Math.min(1., LUTable[Y*3 + i]) ) );
                    }
                }
                return LUTable;
            }

            //干渉色変換のルックアップテーブル生成
            let LUTable;
            LUTable = makeLUTable();

            // 1フレームごとに呼び出される処理
            function tick() {
                // カメラの映像をCanvasに描画する
                offscreenCtx.drawImage(video, 0, 0);

                // イメージデータを取得する（[r,g,b,a,r,g,b,a,...]のように1次元配列で取得できる）
                const imageData = offscreenCtx.getImageData(0, 0, offscreen.width, offscreen.height);
                // imageData.dataはreadonlyなのでfilterメソッドで直接書き換える
                filter(imageData.data);

                // オフスクリーンCanvasを更新する
                offscreenCtx.putImageData(imageData, 0, 0);

                // 表示用Canvasに描画する
                ctx.drawImage(offscreen, 0, 0);

                // 次フレームを処理する
                window.requestAnimationFrame(tick);
            }

            function filter(imgr) {
                // 画像処理を行う
                for (let j = 0; j < imgr.length; j += 4) {
                    //グレースケール変換
                    let Y = Math.round ( 0.299*imgr[j] + 0.587*imgr[j+1] + 0.114*imgr[j+2] );
                    //干渉色変換                    
                    imgr[j]   = LUTable[Y*3];
                    imgr[j+1] = LUTable[Y*3+1];
                    imgr[j+2] = LUTable[Y*3+2];
                }
            }
        }

        main();
        document.getElementById('save').addEventListener('click', function(){
            this.href = document.getElementById('canvas').toDataURL();
        });
    </script>
</body>
</html>
