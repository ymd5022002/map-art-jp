<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang ="ja">
  <head>
      <title>干渉色変換ツール(お試し版)</title>
      <meta http-equiv="Content-Language" content="ja">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
  </head>
  <body bgcolor="#FCE3CD" text="#663236" > <!--HTML5非推奨記載なので別途CSSに移行予定-->        
      <!-- link="リンク文字色 " alink="選択中リンク文字色" vlink="訪問済みリンク文字色"> -->
        <div>
          <h2 style="display:inline;">干渉色変換ツール</h2>　<b>#世界を干渉色に</b><h2 style="display:inline;"> </h2><br>
          画像を素敵な虹色の干渉色に変換するツールです<br><br>

          <span><b>変換したい画像</b></span><small>　(tiff形式は対応しておりません)</small><br>
          <input type="file" id="selectfile" accept='image/*'><input type="button" id="btn1" value="クリア" onclick="fileReset();"><br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          <span><b>繰返し回数</b></span>
          <input id="repeatTimes" type="number" value="1" min="0" step="0.1" style="width:60px;" onkeyup="this.nextSibling.value = this.value; " onchange ="interferanceColorFilter();"/><input type="range" value="1" min="0" max="10" step="0.1" oninput="this.previousSibling.value = this.value; " onchange ="interferanceColorFilter();" /><br> 
          <span style = "font-size:small">　(最小から最大輝度の間に干渉色を何周繰返すか)</span><br>
          <span><b>位相(%)</b></span>
          <input id="phaseRate" type="number" value="0" min="0" step="1"style="width:60px;" onkeyup="this.nextSibling.value = this.value; " onchange ="interferanceColorFilter();"/><input type="range" value="0" min="0" max="100" step="1" oninput="this.previousSibling.value = this.value; " onchange ="interferanceColorFilter();" /><br> 
          <span style = "font-size:small">　(干渉色の位相のずらし量:0-99%)</span><br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          表示サイズ<input type="button" value ="＋" id="large" onclick="changeSize(ratio= 2**0.25)"><input type="button" value ="－" id="small" onclick="changeSize(ratio= 2**(-0.25))">
          　位置<input type="button" value ="たて" id="alignVertical" onclick="alignVertical()"><input type="button" value ="よこ" id="alignHorizontal" onclick="alignHorizontal()">
           <input type="button" value ="⇔" id="swap" onclick="swap()">
          <span id ="dislaySize">
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          <span><b>画像変換結果｜　<a href='#' download='icepic.png' id="save">保存</a>　｜</b></span><br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          <canvas id="dstCanvas" hidden="hidden"></canvas>
          <canvas id="srcCanvas" hidden="hidden"></canvas>
          <span id="output">
          <img style='vertical-align:middle;' id='dstImg'><span id="newLine"></span><img style='vertical-align:middle;' id='srcImg'>
          </span>          
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
  
        </div>
    <hr size="1">
    (C)<a href="https://ymd5022002.github.io/map-art-jp/" target="_blank">地図アート研究所<a>  (MapArtResearch)<br>

    <script>

      //グレースケールを干渉色に変換するルックアップテーブルを作成する関数            
      function makeLUTable(repeatTimes, phaseRate){  
        let LUTable = [];
        //////干渉色パラメータ
        let t_iC = [0.64 , 0.35 , 0.355];    //振幅　amplitude
        let c_iC = [ 0.5 , 0.5 , 0.5];       //中心値
        let u_iC = [ 0.5 , 0.52 , 0.5];      //位相率
        let k_iC = [ 2.98 , 3.71 , 4.35];    //波数
        let s_iC = [ 0.105 , 0. , 0.];       //波長増加率
        let alpha_iC = [ 0.2 , 0.53 , 0.5];  //包絡振幅
        let delta_iC = [ 0.5 , 0.1 , 0.042]; //包絡位相率
        let beta_iC  = [ 0.7 , 0.45 , 0.35]; //包絡波数
        let cycle = repeatTimes;             //色繰返し回数
        let fullscale = 255.;                //画像輝度の最大値(最大は何メートルか)
        let Num_iC = fullscale / cycle;      //色１周期で輝度幾つか(色１周期で何メートルか）
        let scale  = 1000. / fullscale;      //画像輝度値の幅を1000に規格化する係数
        let r_iC = 0.15;                     //不使用階調率(15%)

        for (let Y = 0; Y < 255; Y++) {
          let n_iC = (Y + (phaseRate / 100. * 256.) / repeatTimes ) % Num_iC ;           //色一周期の何番目か
          for (let i = 0; i < 3; i++ ){
            LUTable[Y * 3 + i] =
              c_iC[i] +
              t_iC[i] *
                (1 +
                  alpha_iC[i] *
                    Math.cos(
                      (2 * Math.PI * beta_iC[i] * (n_iC / Num_iC + r_iC)) /
                        (1 + r_iC) -
                        2 * Math.PI * delta_iC[i]
                    )) *
                Math.cos(
                  (2 *
                    Math.PI *
                    (1 + (s_iC[i] * (n_iC / Num_iC + r_iC)) / (1 + r_iC)) *
                    k_iC[i] *
                    (n_iC / Num_iC + r_iC)) /
                    (1 + r_iC) -
                    2 * Math.PI * u_iC[i]
                );
            if ( LUTable[Y*3 + i] > 0.0031308 ){
              LUTable[Y*3 + i] = 1.055 * ( LUTable[Y*3 + i] ** (1/2.4) ) - 0.055;
            }else{
              LUTable[Y*3 + i] = 12.92 * LUTable[Y*3 + i];
            }
            LUTable[Y*3 + i] = Math.round(
              255. * Math.max( 0. , Math.min(1., LUTable[Y*3 + i]))
            );
          }
        }
        return LUTable;
      }

      //前処理１(元画像のメモリを準備する)関数
      function filterSrcPrep(srcCanvasId, width, height){
        // 処理後画像用キャンバス(非表示)を準備
        var srcCanvas = document.getElementById(srcCanvasId);
        var srcContext = srcCanvas.getContext('2d');
        // メモリに元画像データを入れる
        var srcData = srcContext.getImageData(0, 0, width, height);
        return srcData;
      }

      //前処理2(処理後画像のメモリを準備する)関数
      function filterDstPrep(dstCanvasId, width, height){
        // 処理後画像用キャンバス(非表示)を準備
        var dstCanvas = document.getElementById(dstCanvasId);
        var dstContext = dstCanvas.getContext('2d');
        dstCanvas.width = width;
        dstCanvas.height = height;          
        //処理後画像用メモリを準備
        var dstData = dstContext.createImageData(width, height);
        return dstData
      }

      //後処理(処理後画像を描画する)関数
      function drawDstImg(dstCanvasId, dstData){
        // 処理後画像をキャンバス(非表示)に描画
        var dstCanvas = document.getElementById(dstCanvasId);
        var dstContext = dstCanvas.getContext('2d');  
        dstContext.putImageData(dstData, 0, 0);
        // 処理後画像のbase64データ(URL)をキャンバス(非表示)から取得
        var dataDstUrl = dstCanvas.toDataURL();
        // 処理後画像用のimg要素にbase64データ(URL)データを入れて画像を表示
        var dstImgDoc = document.getElementById("dstImg");
        dstImgDoc.src = dataDstUrl;
        var srcImgDoc = document.getElementById("srcImg"); 
        dstImgDoc.width = srcImgDoc.width;
        dstImgDoc.height = srcImgDoc.height;
        dstImgDoc.style.visibility='visible';
        //　保存用の画像にデータを保存
        document.getElementById("save").href = dataDstUrl;
      }

      // 干渉色画像変換処理関数
      function interferanceColorFilter(){

        //メモリの準備をする
        var srcCanvasId = "srcCanvas";
        var dstCanvasId = "dstCanvas";
        var width = document.getElementById(srcCanvasId).width;
        var height = document.getElementById(srcCanvasId).height;
        var srcData = filterSrcPrep(srcCanvasId, width, height );
        var dstData = filterDstPrep(dstCanvasId, width, height );
        var src = srcData.data;
        var dst = dstData.data;

        /////// ここから下に画像処理内容を記述 入力:src, 出力:dst　///////

        //各入力値を取得
        let repeatTimes = Number(document.getElementById( "repeatTimes" ).value);
        let phaseRate = Number(document.getElementById( "phaseRate" ).value);
        let phase = Math.round( 256./100. * phaseRate )

        //干渉色変換のルックアップテーブル生成
        let LUTable;
        LUTable = makeLUTable(repeatTimes, phaseRate);        

        for (var i = 0; i < height; i++) {
          for (var j = 0; j < width; j++) {
            var idx = (j + i * width) * 4;
            var gray = Math.round (
              0.299*src[idx] + 0.587*src[idx + 1] + 0.114*src[idx + 2]
            );
            dst[idx] = LUTable[ ( gray ) % 255 * 3 ];         //Red-ch
            dst[idx + 1] = LUTable[ ( gray ) % 255 * 3 + 1 ]; //Green-ch
            dst[idx + 2] = LUTable[ ( gray ) % 255 * 3 + 2 ]; //Blue-ch
            dst[idx + 3] = src[idx + 3];                              //Alpha-ch
          }
        }

        //////// 画像処理内容はここまで　///////
        
        //画像処理結果を描画する
        drawDstImg(dstCanvasId, dstData);
      }

      function alignVertical(){
        document.getElementById("newLine").innerHTML = "<br>";
      }

      function alignHorizontal(){
          document.getElementById("newLine").innerHTML = "";
      }

      function swap(){
          var srcImgDoc = document.getElementById("srcImg")
          var dstImgDoc = document.getElementById("dstImg")
              dataSrcUrl = srcImgDoc.src;
              dataDstUrl = dstImgDoc.src;
              srcImgDoc.src = dataDstUrl;
              dstImgDoc.src = dataSrcUrl;
              srcImgDoc.id = "dstImg";
              dstImgDoc.id = "srcImg";
      }

      function changeSize(ratio){
        var srcImgDoc = document.getElementById("srcImg");
        var dstImgDoc = document.getElementById("dstImg");
        var dispWidth = srcImgDoc.width; 
        var dispHeight = srcImgDoc.height;
        if ( ( ratio < 1 ) && ( ( dispWidth < 200 ) && ( dispHeight < 200 ) ) ) { return; }
        srcImgDoc.width  *= ratio;
        srcImgDoc.height *= ratio;
        dstImgDoc.width  *= ratio;
        dstImgDoc.height *= ratio;
        return;
      }

      function fileReset(){
        document.getElementById("selectfile").value = "";
        document.getElementById("srcImg").style.visibility='hidden';
        document.getElementById("dstImg").style.visibility='hidden';
        document.getElementById("save").href = "";
        var srcCanvas = document.getElementById("srcCanvas")
        var srcContext = srcCanvas.getContext('2d');
        var width = srcCanvas.width
        var height = srcCanvas.height
        var dstCanvas = document.getElementById("dstCanvas");
        var dstContext = dstCanvas.getContext('2d');
        srcContext.clearRect(0, 0, width, height);
        dstContext.clearRect(0, 0, width, height);        
      }
      
      window.addEventListener("DOMContentLoaded", function(){
        //■HTML読込完了時の処理■
        var ofd = document.getElementById("selectfile");
        ofd.addEventListener("change",function(evt){
          //■選択ファイル変更完了時の処理■
          var img = null;
          var file = evt.target.files;
          var reader = new FileReader();
          //dataURL形式でファイルを読み込む
          reader.readAsDataURL(file[0]);
          reader.onload = function(){
            //■ファイルのロード完了時の処理■
            img = new Image();
            img.onload = function(){
              //■画像の読込完了時の処理■
              var width = img.width;
              var height = img.height;
              var ratio = 0.5 / Math.floor( Math.max(512, Math.max(width, height)) / 512 );
              var dispWidth = Math.round(ratio * width);
              var dispHeight = Math.round(ratio * height);
              var srcCanvas = document.getElementById("srcCanvas");
              var srcContext = srcCanvas.getContext('2d');
              srcCanvas.width = width;
              srcCanvas.height = height; 

              // 元画像の描画
              srcContext.drawImage(img, 0, 0);  // 元画像をキャンバス(非表示)に描画
              var dataSrcUrl = srcCanvas.toDataURL(); // 元画像のbase64データ(URL)をキャンバス(非表示)から取得
              var srcImgDoc = document.getElementById("srcImg"); // 元画像用のimg要素にbase64データ(URL)データを入れて画像を表示
              srcImgDoc.src = dataSrcUrl;
              srcImgDoc.width = dispWidth;
              srcImgDoc.height = dispHeight;
              srcImgDoc.style.visibility='visible';

              //　画像処理と処理画像の描画
              interferanceColorFilter();
            };
            img.src = reader.result;
          };
        }, false);
      });
    </script>
  </body>
  </html>
