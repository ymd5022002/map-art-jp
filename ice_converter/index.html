
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang ="ja">
  <head>
      <title>干渉色変換ツール(お試し版)</title>
      <meta http-equiv="Content-Language" content="ja">
      <meta http-equiv="Content-Type" content="text/html; charset=Shift-JIS">
      <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
  </head>
  <body bgcolor="#FCE3CD" text="#663236" > <!--HTML5非推奨記載なので別途CSSに移行予定-->        
      <!-- link="リンク文字色 " alink="選択中リンク文字色" vlink="訪問済みリンク文字色"> -->
        <div>
          <h2>干渉色変換ツール　#世界を干渉色に</h2>
          画像を素敵な虹色の干渉色に変換するツールです<br><br>

          【使い方】<br>
          1.干渉色の繰返し回数の設定(※)<br>

          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          <span><b>　繰返し回数</b></span>
          <input id="repeatTimes" value="1" type="text" style="width:60px;" onkeyup="this.nextSibling.value = this.value"/><input type="range" value="1" min="0" max="10" step="0.1" oninput="this.previousSibling.value = this.value" /><br> 
          <span style = "font-size:small">　(最小から最大輝度の間に干渉色を何周繰返すか)</span><br>
          <br>
          <small>※ファイル選択前に設定してください。<br>
          画像表示後に変更したい場合、別の画像を一度開いて<br>
          から、繰返し回数を変え、再度画像を開いてください<br>
          (別途、使い勝手を向上する予定です)</small><br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>

          2.ファイルの選択<br>

          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          　<input type="file" id="selectfile" accept='image/*'><br>
          <small>　(tiff形式は対応しておりません)</small><br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>

          3.｜　<a href='#' download='icepic.png' id="save">保存</a>　｜で干渉色画像を保存できます<br>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          　表示サイズ<input type="button" value ="＋" id="large" onclick="changeSize(ratio= 2**0.25)">
          <input type="button" value ="－" id="small" onclick="changeSize(ratio= 2**(-0.25))">
          　位置<input type="button" value ="たて" id="tate" onclick="tate()">
          <input type="button" value ="よこ" id="yoko" onclick="yoko()">
          　<input type="button" value ="⇔" id="swap" onclick="swap()">
          <span id ="dislaySize">
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
          <span id="output"></span>
          <div id="separator" style="border: 5; margin: 5px; background-color: #FCE3CD; min-height: 3px;"></div>
  
        </div>
    (C)<a href="https://ymd5022002.github.io/map-art-jp/" target="_blank">地図アート研究所<a>  (MapArtResearch)<br>
    <script>
      //干渉色変換関数
      var interferanceColorFilter = function(src, dst, width, height) {
          //各入力値(文字列)を取得
          let str_repeatTimes = document.getElementById( "repeatTimes" ).value;
          //文字列を数値に変換
          let repeatTimes = Number(str_repeatTimes);
          //干渉色変換のルックアップテーブル生成
        
          let LUTable;
          LUTable = makeLUTable(repeatTimes);
  
          for (var i = 0; i < height; i++) {
              for (var j = 0; j < width; j++) {
                  var idx = (j + i * width) * 4;
                  var gray = Math.round (
                    0.299*src[idx] + 0.587*src[idx + 1] + 0.114*src[idx + 2]
                  );
                  //=(src[idx] + src[idx + 1] + src[idx + 2]) / 3;      
                  dst[idx] = LUTable[ gray * 3 ];           // gray
                  dst[idx + 1] = LUTable[ gray * 3 + 1 ];   // gray;
                  dst[idx + 2] = LUTable[ gray * 3 + 2 ];   // gray;
                  dst[idx + 3] = src[idx + 3];
              }
          }
      };

      function tate(){
        document.getElementById("kaigyou").innerHTML = "<br>";
      }

      function yoko(){
          document.getElementById("kaigyou").innerHTML = "";
      }

      function swap(){
          var targetImg0 = document.getElementById("out0")
          var targetImg1 = document.getElementById("out1")
              dataurl0 = targetImg0.src;
              dataurl1 = targetImg1.src;
              targetImg0.src = dataurl1;
              targetImg1.src = dataurl0;
      }

      function changeSize(ratio){
        var targetImg0 = document.getElementById("out0");
        var targetImg1 = document.getElementById("out1");
        var w = targetImg0.width; 
        var h = targetImg0.height;
        if ( ( ratio < 1 ) && ( ( w < 200 ) && ( h < 200 ) ) ) { return; }
        targetImg0.width  = w * ratio;
        targetImg0.height = h * ratio;
        targetImg1.width  = w * ratio;
        targetImg1.height = h * ratio;
        return;
      }

      //グレースケールを干渉色に変換するルックアップテーブルを作成する処理            
      function makeLUTable(repeatTimes){
  
        let LUTable = [];
        //////干渉色パラメータ
        let t_iC = [0.64 , 0.35 , 0.355];    //振幅　amplitude
        let c_iC = [ 0.5 , 0.5 , 0.5];       //中心値
        let u_iC = [ 0.5 , 0.52 , 0.5];      //位相率
        let k_iC = [ 2.98 , 3.71 , 4.35];    //波数
        let s_iC = [ 0.105 , 0. , 0.];       //波長増加率
        let alpha_iC = [ 0.2 , 0.53 , 0.5];  //包絡振幅
        let delta_iC = [ 0.5 , 0.1 , 0.042]; //包絡位相率
        let beta_iC  = [ 0.7 , 0.45 , 0.35]; //包絡波数
  
        let cycle = repeatTimes;             //色繰返し回数
        let fullscale = 255.;                //画像輝度の最大値(最大は何メートルか)
        let Num_iC = fullscale / cycle;      //色１周期で輝度幾つか(色１周期で何メートルか）
        let scale  = 1000. / fullscale;      //画像輝度値の幅を1000に規格化する係数
        let r_iC = 0.15;                     //不使用階調率(15%)
  
        for (let Y = 0; Y < 256; Y +=1) {
          let n_iC = Y % Num_iC;           //色一周期の何番目か
          for (let i = 0; i < 3; i +=1 ){
            LUTable[Y * 3 + i] =
              c_iC[i] +
              t_iC[i] *
                (1 +
                  alpha_iC[i] *
                    Math.cos(
                      (2 * Math.PI * beta_iC[i] * (n_iC / Num_iC + r_iC)) /
                        (1 + r_iC) -
                        2 * Math.PI * delta_iC[i]
                    )) *
                Math.cos(
                  (2 *
                    Math.PI *
                    (1 + (s_iC[i] * (n_iC / Num_iC + r_iC)) / (1 + r_iC)) *
                    k_iC[i] *
                    (n_iC / Num_iC + r_iC)) /
                    (1 + r_iC) -
                    2 * Math.PI * u_iC[i]
                );
            if ( LUTable[Y*3 + i] > 0.0031308 ){
              LUTable[Y*3 + i] = 1.055 * ( LUTable[Y*3 + i] ** (1/2.4) ) - 0.055;
            }else{
              LUTable[Y*3 + i] = 12.92 * LUTable[Y*3 + i];
            }
            LUTable[Y*3 + i] = Math.round(
              255. * Math.max( 0. , Math.min(1., LUTable[Y*3 + i]))
            );
          }
        }
        return LUTable;
      }
  
      window.addEventListener("DOMContentLoaded", function(){
          //ファイルオープンの際のイベント
          var ofd = document.getElementById("selectfile");

          ofd.addEventListener(
            "change",
            function(evt) {
              var img = null;
              var canvas = document.createElement("canvas");
              //var canvas = document.getElementById('canvas');
  
              var file = evt.target.files;
              var reader = new FileReader();
  
              //dataURL形式でファイルを読み込む
              reader.readAsDataURL(file[0]);
  
              //ファイルの読込が終了した時の処理
              reader.onload = function(){
                  img = new Image();
                  img.onload = function(){
                      //キャンバスに画像をセット
                      var context = canvas.getContext('2d');
                      var width = img.width;
                      var height = img.height;
                      canvas.width = width;
                      canvas.height = height;
                      var ratio = 0.5 / Math.floor( Math.max(width, height) / 512 ) 
                      dispWidth = String(Math.round(ratio * width))
                      dispHeight = String(Math.round(ratio * height))

                      context.drawImage(img, 0, 0);
                      var dataurl0 = canvas.toDataURL();
  
                      //フィルター処理
  
                      var srcData = context.getImageData(0, 0, width, height);
                      var dstData = context.createImageData(width, height);
                      var src = srcData.data;
                      var dst = dstData.data;
                      interferanceColorFilter(src, dst, width, height);
                      context.putImageData(dstData, 0, 0);
  
                      //画像タグに代入して表示
                      var dataurl = canvas.toDataURL();
                      document.getElementById("output").innerHTML = 
                      `<img src='${dataurl}' style='vertical-align:middle;' height='${dispHeight}' width='${dispWidth}' id='out1'><span id="kaigyou"></span><img src='${dataurl0}' style='vertical-align:middle;' height='${dispHeight}' width='${dispWidth}' id='out0'>`;
                    document.getElementById("save").href = dataurl;
                  };
                  img.src = reader.result;
              };
          }, 
          false
        );
      });
    </script>
  </body>
  </html>
  
